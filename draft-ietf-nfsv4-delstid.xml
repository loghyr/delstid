<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<rfc
 category="std"
 docName="draft-ietf-nfsv4-delstid-VERSIONVAR"
 ipr="trust200902"
 obsoletes=""
 scripts="Common,Latin"
 sortRefs="true"
 submissionType="IETF"
 symRefs="true"
 tocDepth="3"
 tocInclude="true"
 updates="8881"
 version="3"
 xml:lang="en">

<front>
  <title abbrev="Deleg Stateid">
    Extending the Opening of Files in NFSv4.2
  </title>
  <seriesInfo name="Internet-Draft" value="draft-ietf-nfsv4-delstid-VERSIONVAR"/>
  <author fullname="Thomas Haynes" initials="T." surname="Haynes">
    <organization abbrev="Hammerspace">Hammerspace</organization>
    <address>
      <email>loghyr@hammerspace.com</email>
    </address>
  </author>
  <author fullname="Trond Myklebust" initials="T." surname="Myklebust">
    <organization abbrev="Hammerspace">Hammerspace</organization>
    <address>
      <email>trondmy@hammerspace.com</email>
    </address>
  </author>
  <date year="YEARVAR" month="MONTHVAR" day="DAYVAR"/>
  <area>Transport</area>
  <workgroup>Network File System Version 4</workgroup>
  <keyword>NFSv4</keyword>
  <abstract>
    <t>
      The Network File System v4 (NFSv4) allows a client to both open a
      file and be granted a delegation of that file.  This delegation
      provides the client the right to authoritatively cache metadata
      on the file locally.  This document presents several extensions
      to RFC8881 for both the opening and delegating of the file  to
      the client.
    </t>
  </abstract>

  <note removeInRFC="true">
    <t>
      Discussion of this draft takes place
      on the NFSv4 working group mailing list (nfsv4@ietf.org),
      which is archived at
      <eref target="https://mailarchive.ietf.org/arch/browse/nfsv4/"/>.
      Working Group information can be found at
      <eref target="https://datatracker.ietf.org/wg/nfsv4/about/"/>.
    </t>
  </note>
</front>

<middle>

<section anchor="sec_intro" numbered="true" removeInRFC="false" toc="default">
  <name>Introduction</name>
  <t>
    In the Network File System version4 (NFSv4), a client may be granted
    a delegation for a file. This allows the client to act as the
    authority for the file's metadata and data. This document presents
    a number of extensions which enhance the functionality of opens and
    delegations. These allow the client to:
  </t>
  <ul spacing="normal">
    <li>
      detect an offline file, which may require significant effort to obtain.
    </li>
    <li>
      determine which extensions of OPEN (see Section 18.16 of <xref
      target="RFC8881" format="default" sectionFormat="of"/>) flags are
      supported by the server.
    </li>
    <li>
      during the OPEN procedure, get either the open
      or delegation stateids, but not both.
    </li>
    <li>
      cache both the access and modify times, reducing the
      number of times the client needs to go to the server
      to get that information.
    </li>
  </ul>

  <t>
    Using the process detailed in <xref target="RFC8178" format="default"
    sectionFormat="of"/>, the revisions in this document become an
    extension of NFSv4.2 <xref target="RFC7862" format="default"
    sectionFormat="of"/>. They are built on top of the external data
    representation (XDR) <xref target="RFC4506" format="default"
    sectionFormat="of"/> generated from <xref target="RFC7863"
    format="default" sectionFormat="of"/>.
  </t>

  <section anchor="sec_defs" numbered="true" removeInRFC="false" toc="default">
    <name>Definitions</name>
    <dl newline="false" spacing="normal">
      <dt>delegation:</dt>
      <dd>
        A file delegation, which is a recallable lock that assures the
        holder that inconsistent opens and file changes cannot occur so
        long as the delegation is held.
      </dd>
      <dt>proxy:</dt>
      <dd>
        Proxying of attributes occurs when a client has the authority
        to represent the attributes normally maintained by the server.
        The client having this authority is the "proxy" for those
        attributes.
      </dd>
      <dt>stateid:</dt>
      <dd>
        A stateid is a 128-bit quantity returned by a server that uniquely
        designates state held by the server for the client. (See Section
        8 of <xref target="RFC8881" format="default" sectionFormat="of"/>)
      </dd>
    </dl>
  </section>
  <section numbered="true" removeInRFC="false" toc="default">
    <name>Requirements Language</name>
    <t>
      The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
      "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
      NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
      "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
      "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this
      document are to be interpreted as described in BCP&nbsp;14 <xref
      target="RFC2119" format="default" sectionFormat="of"/> <xref
      target="RFC8174" format="default" sectionFormat="of"/> when,
      and only when, they appear in all capitals, as shown here.
    </t>
  </section>
</section>

<section anchor="sec_offline" numbered="true" removeInRFC="false" toc="default">
  <name>Offline Files</name>
  <t>
    If a file is offline, then the server has immediate high-performance
    access to the file's attributes, but not to the file's content.
    The cost of retrieving the data content is expensive, to the extent
    that the content should only be retrieved if it is going to be used.
    For example, a graphical file manager (such as OSX's Finder) may want
    to access the beginning of the file to preview it for an user who is
    hovering their pointer over the file name.  If the file is retrieved,
    it will most likely either be immediately thrown away or returned.
  </t>
  <t>
    A compound with a GETATTR or READDIR can report the file's attributes
    without bringing the file online.  However, either an OPEN or a
    LAYOUTGET might cause the file server to retrieve the archived
    data contents, bringing the file online.  For non-pNFS systems,
    the OPEN operation requires a filehandle to the data content. For
    pNFS systems, the filehandle retrieved from an OPEN need not cause
    the data content to be retrieved. But when the LAYOUTGET operation
    is processed, a layout type specific mapping will cause the data
    content to be retrieved from offline storage.
  </t>
  <t>
    If an operating system is not aware that the file is offline, it
    might inadvertently open the file to determine what type of file it is
    accessing.  By adding the new attribute FATTR4_OFFLINE, a client can
    predetermine the availability of the file, avoiding the need to open
    it at all. Being offline might also involve situations in which the
    file is archived in the cloud, i.e., there can be an expense in both
    retrieving the file to bring online and in sending the file back to
    offline status.
  </t>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// typedef bool            fattr4_offline;
///
]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// const FATTR4_OFFLINE            = 83;
///
]]>
  </sourcecode>
</section>

<section anchor="sec_open_xor" numbered="true" removeInRFC="false" toc="default">
  <name>OPEN grants only one of Open or Delegation Stateid</name>
  <t>
    The OPEN (See Section 18.16 of <xref target="RFC8881" format="default"
    sectionFormat="of"/>) procedure returns an open stateid to the
    client to reference the state of the file.  The client could also
    request a delegation stateid in the OPEN arguments.  The file can
    be considered open for the client as long as the count of open
    and delegated stateids is greater than 0.  Either type of stateid
    is sufficient to enable the server to treat the file as if it were
    open, which allows READ (See Section 18.25 of <xref target="RFC8881"
    format="default" sectionFormat="of"/>), WRITE (See Section 18.38
    of <xref target="RFC8881" format="default" sectionFormat="of"/>),
    LOCK (See Section 18.12 of <xref target="RFC8881" format="default"
    sectionFormat="of"/>), and LAYOUTGET (see Section 18.50 of <xref
    target="RFC8881" format="default" sectionFormat="of"/>) operations
    to proceed. If the client gets both a open and a delegation stateid
    as part of the OPEN, then it has to return them both.  A further
    consideration is that during each operation, the client can send
    a costly GETATTR (See Section 18.9 of <xref target="RFC8881"
    format="default" sectionFormat="of"/>).
  </t>
  <t>
    If the client knows that the server supports the
    OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION flag (as determined by an
    earlier GETATTR operation which queried for the FATTR4_OPEN_ARGUMENTS
    attribute), then the client can supply that flag during the OPEN
    and only get either an open or delegation stateid.
  </t>
  <t>
    The client is already prepared to not get a delegation
    stateid even if requested. In order to not send an open
    stateid, the server can indicate that fact with the result
    flag of OPEN4_RESULT_NO_OPEN_STATEID. The open stateid field,
    OPEN4resok.stateid (see Section 18.16.2 of <xref target="RFC8881"
    format="default" sectionFormat="of"/>), will  also be set to the
    special all zero stateid.
  </t>
  <section anchor="delstid_analysis" numbered="true" removeInRFC="false" toc="default">
  <name>Implementation Experience</name>
    <t>
      The CLOSE operation neither explicitly nor implicitly releases any
      delegation stateids. This is not symmetrical with the OPEN operation,
      which can grant both an open and a delegation stateid.  This draft
      could have tried to extend the CLOSE operation to release both
      stateids, but implementation experience shows that is more costly
      than the approach which has been proposed.
    </t>
    <t>
      Consider a small workload of creating a file with content. That
      takes 3 synchronous and 1 asynchronous operations with existing
      implementations. The first synchronous one has to OPEN the file,
      the second synchronous one performs the WRITE to the file, the third
      synchronous one has to CLOSE the file, and the fourth asynchronous
      one uses DELEGRETURN to return the delegation stateid.
    </t> 
    <t>
      With the proposed approach of setting the
      OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION flag during
      the OPEN, the number of operations is always 3.  The first two
      compounds are still synchronous, but the last is asynchronous. I.e.,
      since the client no longer has to send a CLOSE operation, it can
      delay the DELEGRETURN until either the server requests it back
      via delegation recall or garbage collection causes the client to
      return the stateid.
    </t>
    <t>
      This approach reduces the cost of synchronous operations by 33%
      and the total number of operations by 25%. Contrast that against
      the alternative proposal of having CLOSE return both stateids,
      which would not reduce the number of synchronous operations.
    </t>
  </section>
</section>

<section anchor="sec_proxy" numbered="true" removeInRFC="false" toc="default">
  <name>Proxying of Times</name>
  <t>
    When a client is granted a write delegation on a file, it is the
    authority for the file. If the server queries the client as to
    the state of the file via a CB_GETATTR (see Section 20.1 of <xref
    target="RFC8881" format="default" sectionFormat="of"/>), then it
    can only determine the size of the file. Likewise, if the client
    holding the delegation wants to know either of the access, modify,
    or change times, it has to send a GETATTR to the server.  While it
    is the authority for these values, it has no way to transfer these
    values to the server when the delegation is being returned and the
    server reclaims its authority with regard to these values.  And as
    such, it can not pass these times up to an application expecting
    posix compliance.
  </t>
  <t>
    With the addition of the new flag:
    OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS, the client and server can
    negotiate that the client will be the authority for these values and
    upon return of the delegation stateid via a DELEGRETURN (see section
    18.6 of <xref target="RFC8881" format="default" sectionFormat="of"/>),
    the times will be passed back to the server. If the server is queried
    by another client for either the size or the times, it will need to
    use a CB_GETATTR to query the client which holds the delegation
    (see Section 20.1 of <xref target="RFC8881" format="default"
    sectionFormat="of"/>).
  </t>
  <t>
    If a server informs the client via the FATTR4_OPEN_ARGUMENTS attribute
    that it supports OPEN_ARGS_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS
    and it returns a valid delegation stateid for an OPEN operation
    which sets the OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS flag,
    then it <bcp14>MUST</bcp14> query the client via a CB_GETATTR for the
    FATTR4_TIME_DELEG_ACCESS attribute and FATTR4_TIME_DELEG_MODIFY
    attribute. (The change time can be derived from the modify
    time.) Further, when it gets a SETATTR (see Section 18.34 of
    <xref target="RFC8881" format="default" sectionFormat="of"/>) in
    the same compound as the DELEGRETURN, then it <bcp14>MUST</bcp14> accept those
    FATTR4_TIME_DELEG_ACCESS attribute and FATTR4_TIME_DELEG_MODIFY
    attribute changes and derive the change time or reject the changes
    with NFS4ERR_DELAY.
  </t>
  <t>
    Note that the SETATTR <bcp14>SHOULD</bcp14> either be in
    a separate compound before the one containing the DELEGRETURN or
    if in the same compound, as an operation before the DELEGRETURN.
    Failure to properly sequence the operations may lead to race
    cases.
  </t>
  <t>
    A key prerequisite of this approach is that the server and client
    are in time synchronization with each other.  Note that while
    the base NFSv4.2 does not require such synchronization, the
    use of RPCSEC_GSS typically makes such a requirement. When the
    client presents either FATTR4_TIME_DELEG_ACCESS or FATTR4_TIME_DELEG_MODIFY
    attributes to the server, the server <bcp14>MUST</bcp14> decide whether the
    times presented are before the old times or past the current time.
    If the time presented is before the original time, then the
    update is ignored. If the time presented is in the future, the
    server can either clamp the new time to the current time, or
    it may return NFS4ERR_DELAY to the client, allowing it to retry.
    Note that if the clock skew is large, this policy will result
    in access to the file being denied until such time that the
    clock skew is exceeded.
  </t>
  <t>
    A change in the access time <bcp14>MUST NOT</bcp14> advance the change time,
    also known as the time_metadata attribute (see Section 5.8.2.42 of
    <xref target="RFC8881" format="default" sectionFormat="of"/>), but a
    change in the modify time might advance the change time (and in turn
    the change attribute (See Section 5.8.1.4 of <xref target="RFC8881"
    format="default" sectionFormat="of"/>).  If the modify time is greater
    than the change time and before the current time, then the change time
    is adjusted to the modify time and not the current time (as is most
    likely done on most SETATTR calls that change the metadata). If the
    modify time is in the future, it will be clamped to the current time.
  </t>
  <t>
    Note that each of the possible times, access, modify, and change, are
    compared to the current time. They should all be compared against
    the same time value for the current time. I.e., do not retrieve
    a different value of the current time for each calculation.
  </t>
  <t>
    If the client sets the OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS
    flag in an OPEN operation, then it <bcp14>MUST</bcp14> support
    the FATTR4_TIME_DELEG_ACCESS
    and FATTR4_TIME_DELEG_MODIFY attributes both in the CB_GETATTR
    and SETATTR operations.
  </t>

  <section anchor="ssec_proxy_use" numbered="true" removeInRFC="false" toc="default">
    <name>Use case</name>
    <t>
      When a server is a proxy for a NFSv4 server, it is a client
      to the NFSv4 server and during file I/O, it may get a delegation
      on a file. The client of the proxy would be querying the
      proxy for attributes and not the NFSv4 server.  Each GETATTR
      from that client would result in at least one additional
      GETATTR being sent across the wire.
    </t>
  </section>

  <section anchor="ssec_proxy_xdr" numbered="true" removeInRFC="false" toc="default">
    <name>XDR for Proxying of Times</name>
    <sourcecode name="" type="" markers="true"><![CDATA[
///
/// /*
///  * attributes for the delegation times being
///  * cached and served by the "client"
///  */
/// typedef nfstime4        fattr4_time_deleg_access;
/// typedef nfstime4        fattr4_time_deleg_modify;
///
 ]]>
    </sourcecode>
    <sourcecode name="" type="" markers="true"><![CDATA[
///
/// %/*
/// % * New RECOMMENDED Attribute for
/// % * delegation caching of times
/// % */
/// const FATTR4_TIME_DELEG_ACCESS  = 84;
/// const FATTR4_TIME_DELEG_MODIFY  = 85;
///
 ]]>
    </sourcecode>
    <sourcecode name="" type="" markers="true"><![CDATA[
///
/// const OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS = 0x100000;
///
 ]]>
    </sourcecode>
  </section>
</section>

<section anchor="ssec_open_xor_xdr" numbered="true" removeInRFC="false" toc="default">
  <name>Determining OPEN Feature Support</name>
  <t>
    <xref target="RFC8178" format="default" sectionFormat="of"/>
    (see Section 4.4.2) allows for extending a particular minor
    version of the NFSv4 protocol without requiring the definition
    of a new minor version.  The client can probe the capabilities of
    the server and based on the result, determine if both it and the
    server support optional features not previously specified as part
    of the minor version.
  </t>
  <t>
    The fattr4_open_arguments attribute is a new XDR extension which
    provides helpful support when the OPEN procedure is extended in
    such a fashion. It models all of the parameters via bitmap4 data
    structures, which allows for the addition of a new flag to any of
    the OPEN arguments (see Section 18.16.1 of <xref target="RFC8881"
    format="default" sectionFormat="of"/>). The scope of this attribute
    applies to all objects with a matching fsid.
  </t>
  <t>
    Two new flags are provided:
  </t>
  <ul spacing="normal">
    <li>
      OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION (see <xref target="sec_open_xor" format="default" sectionFormat="of"/>)
    </li>
    <li>
      OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS (see <xref target="sec_proxy" format="default" sectionFormat="of"/>)
    </li>
  </ul>
  <t>
    Subsequent extensions can use this framework when introducing new
    <bcp14>OPTIONAL</bcp14> functionality to OPEN, by creating a new
    flags for each <bcp14>OPTIONAL</bcp14> parameter.
  </t>
  <t>
    Since fattr4_open_arguments is a <bcp14>RECOMMENDED</bcp14> attribute, if the
    server informs the client that it does not support this new
    attribute, the client <bcp14>MUST</bcp14> determine that
    the additional new <bcp14>OPTIONAL</bcp14> functionality to OPEN
    is also not supported.
  </t>
  <t>
    Some other concerns are how to process both currently
    <bcp14>REQUIRED</bcp14> flags and <bcp14>OPTIONAL</bcp14> flags
    which become <bcp14>REQUIRED</bcp14> in the future.  The server
    <bcp14>MUST</bcp14> mark <bcp14>REQUIRED</bcp14> as being supported.
    Note that as these flags <bcp14>MUST</bcp14> only change from
    <bcp14>OPTIONAL</bcp14> to <bcp14>REQUIRED</bcp14> when the NFSv4
    minor version is incremented.
  </t>
    
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// struct open_arguments4 {
///   bitmap4  oa_share_access;
///   bitmap4  oa_share_deny;
///   bitmap4  oa_share_access_want;
///   bitmap4  oa_open_claim;
///   bitmap4  oa_create_mode;
/// };
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// enum open_args_share_access4 {
///    OPEN_ARGS_SHARE_ACCESS_READ  = 1,
///    OPEN_ARGS_SHARE_ACCESS_WRITE = 2,
///    OPEN_ARGS_SHARE_ACCESS_BOTH  = 3
/// };
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// enum open_args_share_deny4 {
///    OPEN_ARGS_SHARE_DENY_NONE  = 0,
///    OPEN_ARGS_SHARE_DENY_READ  = 1,
///    OPEN_ARGS_SHARE_DENY_WRITE = 2,
///    OPEN_ARGS_SHARE_DENY_BOTH  = 3
/// };
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// enum open_args_share_access_want4 {
///    OPEN_ARGS_SHARE_ACCESS_WANT_ANY_DELEG           = 3,
///    OPEN_ARGS_SHARE_ACCESS_WANT_NO_DELEG            = 4,
///    OPEN_ARGS_SHARE_ACCESS_WANT_CANCEL              = 5,
///    OPEN_ARGS_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL
///                                                    = 17,
///    OPEN_ARGS_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
///                                                    = 18,
///    OPEN_ARGS_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS    = 20,
///    OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION = 21
/// };
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// enum open_args_open_claim4 {
///    OPEN_ARGS_OPEN_CLAIM_NULL          = 0,
///    OPEN_ARGS_OPEN_CLAIM_PREVIOUS      = 1,
///    OPEN_ARGS_OPEN_CLAIM_DELEGATE_CUR  = 2,
///    OPEN_ARGS_OPEN_CLAIM_DELEGATE_PREV = 3,
///    OPEN_ARGS_OPEN_CLAIM_FH            = 4,
///    OPEN_ARGS_OPEN_CLAIM_DELEG_CUR_FH  = 5,
///    OPEN_ARGS_OPEN_CLAIM_DELEG_PREV_FH = 6
/// };
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// enum open_args_createmode4 {
///    OPEN_ARGS_CREATEMODE_UNCHECKED4     = 0,
///    OPEN_ARGS_CREATE_MODE_GUARDED       = 1,
///    OPEN_ARGS_CREATEMODE_EXCLUSIVE4     = 2,
///    OPEN_ARGS_CREATE_MODE_EXCLUSIVE4_1  = 3
/// };
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// typedef open_arguments4 fattr4_open_arguments;
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// %/*
/// % * Determine what OPEN supports.
/// % */
/// const FATTR4_OPEN_ARGUMENTS     = 86;
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// const OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION = 0x200000;
///
 ]]>
  </sourcecode>
  <sourcecode name="" type="" markers="true"><![CDATA[
///
/// const OPEN4_RESULT_NO_OPEN_STATEID = 0x00000010;
///
 ]]>
  </sourcecode>
</section>

<section anchor="xdr_desc" numbered="true" removeInRFC="false" toc="default">
  <name>Extraction of XDR</name>
  <t>
    This document contains the external data representation (XDR)
    <xref target="RFC4506" format="default" sectionFormat="of"/> description of the new open
    flags for delegating the file to the client.
    The XDR description is embedded in this
    document in a way that makes it simple for the reader to extract
    into a ready-to-compile form.  The reader can feed this document
    into the following shell script to produce the machine readable
    XDR description of the new flags:
  </t>
  <sourcecode name="" type="" markers="true"><![CDATA[
#!/bin/sh
grep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'
    ]]>
  </sourcecode>
  <t>
    That is, if the above script is stored in a file called "extract.sh", and
    this document is in a file called "spec.txt", then the reader can do:
  </t>
  <sourcecode name="" type="" markers="true"><![CDATA[
sh extract.sh < spec.txt > delstid_prot.x
    ]]>
  </sourcecode>
  <t>
    The effect of the script is to remove leading white space from each
    line, plus a sentinel sequence of "///".  XDR descriptions with the
    sentinel sequence are embedded throughout the document.
  </t>
  <t>
    Note that the XDR code contained in this document depends on types
    from the NFSv4.2 nfs4_prot.x file (generated from <xref target="RFC7863" format="default" sectionFormat="of"/>).
    This includes both nfs types that end with a 4, such as offset4,
    length4, etc., as well as more generic types such as uint32_t and
    uint64_t.
  </t>
  <t>
    While the XDR can be appended to that from <xref target="RFC7863" format="default" sectionFormat="of"/>,
    the various code snippets belong in their respective areas of the
    that XDR.
  </t>
  <section anchor="code_copyright" numbered="true" removeInRFC="false" toc="default">
    <name>Code Components Licensing Notice</name>
    <t>
       Both the XDR description and the scripts used for extracting the
       XDR description are Code Components as described in Section 4 of
       <xref target="LEGAL" format="default" sectionFormat="of">"Legal
       Provisions Relating to IETF Documents"</xref>.  These Code
       Components are licensed according to the terms of that document.
    </t>
  </section>
</section>

<section anchor="sec_security" numbered="true" removeInRFC="false" toc="default">
  <name>Security Considerations</name>
  <t>
    The features described in this document do not introduce any new security
    considerations.
  </t>
</section>

<section anchor="sec_iana" numbered="true" removeInRFC="false" toc="default">
  <name>IANA Considerations</name>
  <t>
    There are no IANA considerations.
  </t>
</section>

</middle>

<back>

<references>
  <name>References</name>

  <references>
  <name>Normative References</name>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4506.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7862.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7863.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8178.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8881.xml"/>
  </references>

  <references>
  <name>Informative References</name>
    <reference anchor="LEGAL" target="http://trustee.ietf.org/docs/IETF-Trust-License-Policy.pdf">
      <front>
        <title abbrev="Legal Provisions">Legal Provisions Relating to IETF Documents</title>
        <author>
          <organization>IETF Trust</organization>
        </author>
        <date month="November" year="2008"/>
      </front>
    </reference>
  </references>
</references>

<section numbered="true" removeInRFC="false" toc="default">
      <name>Acknowledgments</name>
      <t>
        Trond Myklebust and David Flynn
        all worked on the prototype at Hammerspace.
      </t>
      <t>
        Dave Noveck, Chuck Lever, and Rick Macklem provided reviews of the document.
      </t>
    </section>

</back>

</rfc>
